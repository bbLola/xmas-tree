<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; position: relative; }
        #loading-ui {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; z-index: 100; text-align: center; pointer-events: none;
            text-shadow: 0 0 10px #00ffcc; font-weight: bold;
        }
        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 101;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 15px;
            border: 1px solid #00ffcc; backdrop-filter: blur(10px); color: white;
        }
        button, label {
            padding: 8px 15px; background: #00ffcc; border: none; border-radius: 5px;
            cursor: pointer; font-weight: bold; color: black; margin: 5px 5px 0 0; display: inline-block;
        }
        #video-preview {
            position: absolute; top: 20px; right: 20px; width: 120px; height: 90px;
            border-radius: 10px; border: 2px solid #00ffcc; transform: scaleX(-1);
            background: #111; z-index: 101;
        }
    </style>
</head>
<body>

<div id="loading-ui">æ­£åœ¨åŠ è½½ 3D åœ£è¯ç³»ç»Ÿ...</div>
<div id="root"></div>
<video id="webcam" style="display:none" autoplay playsinline></video>
<canvas id="video-preview"></canvas>

<div class="controls">
    <div style="font-size: 14px; margin-bottom: 8px;">ğŸ„ åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ</div>
    <label for="img-upload">ğŸ“‚ æ’å…¥ç…§ç‰‡æ–‡æ¡£</label>
    <input type="file" id="img-upload" multiple accept="image/*" style="display:none">
    <button onclick="document.documentElement.requestFullscreen()">å…¨å±</button>
    <div style="font-size: 11px; color: #00ffcc; margin-top: 5px;">
        ğŸ–ï¸ å¼ å¼€: æ‰©æ•£æ—‹è½¬ | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
    </div>
</div>

<!-- åŠ è½½ MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://cdn.skypack.dev/react@18.2.0",
    "react-dom": "https://cdn.skypack.dev/react-dom@18.2.0",
    "three": "https://cdn.skypack.dev/three@0.160.0",
    "@react-three/fiber": "https://cdn.skypack.dev/@react-three/fiber@8.15.11",
    "@react-three/drei": "https://cdn.skypack.dev/@react-three/drei@9.92.7"
  }
}
</script>

<script type="module">
import React, { useState, useMemo, useRef, useEffect } from 'react';
import { createRoot } from 'react-dom';
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, Environment, Float, MeshReflectorMaterial, PerspectiveCamera } from '@react-three/drei';

// å…¨å±€çŠ¶æ€å•ä¾‹ï¼Œé¿å… React æ¸²æŸ“å»¶è¿Ÿ
const state = {
    gesture: 'open',
    pinch: false,
    scale: 1,
    ready: false
};

// --- ç²’å­ç³»ç»Ÿç»„ä»¶ ---
const XmasParticles = ({ images }) => {
    const count = 1200;
    const meshRef = useRef();
    const dummy = new THREE.Object3D();
    const [grabbedImg, setGrabbedImg] = useState(null);

    // é¢„è®¾å¤šç§å‡ ä½•ä½“å½¢çŠ¶
    const geometries = useMemo(() => [
        new THREE.SphereGeometry(0.2, 8, 8),      // çƒ
        new THREE.BoxGeometry(0.3, 0.3, 0.3),    // ç¤¼ç‰©
        new THREE.TorusGeometry(0.15, 0.05, 8, 16), // é“ƒé“›
        new THREE.ConeGeometry(0.2, 0.4, 4),     // æ ‘/ä¸‰è§’å½¢
        new THREE.CylinderGeometry(0.1, 0.1, 0.3, 6) // è¢œå­/ç­’
    ], []);

    const particles = useMemo(() => {
        const p = [];
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 137.5 * (Math.PI / 180);
            const r = (1 - t) * 10;
            const wave = Math.sin(t * 30) * 0.5;
            
            // åœ£è¯æ ‘ä½ç½®
            const treePos = new THREE.Vector3(Math.cos(angle) * (r + wave), t * 22 - 10, Math.sin(angle) * (r + wave));
            // åˆå§‹éšæœºä½ç½®
            const randPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*50, (Math.random()-0.5)*60);
            
            p.push({
                treePos,
                randPos,
                currPos: randPos.clone(),
                speed: 0.02 + Math.random() * 0.05,
                geoIdx: Math.floor(Math.random() * geometries.length),
                scale: 0.4 + Math.random() * 0.6
            });
        }
        return p;
    }, []);

    useFrame((s) => {
        const t = s.clock.getElapsedTime();
        const isFist = state.gesture === 'fist';

        particles.forEach((p, i) => {
            let target = isFist ? p.treePos : p.randPos;
            
            // æ•£å¼€æ—¶çš„æ—‹è½¬é€»è¾‘
            if (!isFist) {
                const rot = t * 0.3;
                const x = p.randPos.x;
                const z = p.randPos.z;
                target = new THREE.Vector3(x * Math.cos(rot) - z * Math.sin(rot), p.randPos.y, x * Math.sin(rot) + z * Math.cos(rot));
            }

            p.currPos.lerp(target, 0.06);
            dummy.position.copy(p.currPos);
            dummy.scale.setScalar(p.scale * state.scale);
            dummy.rotation.set(t * p.speed * 10, t * p.speed * 8, 0);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;

        // æåˆæŠ“å–ç…§ç‰‡é€»è¾‘
        if (state.pinch && images.length > 0 && !grabbedImg) {
            const randomImg = images[Math.floor(Math.random() * images.length)];
            setGrabbedImg(randomImg);
        } else if (!state.pinch && grabbedImg) {
            setGrabbedImg(null);
        }
    });

    return (
        <group>
            {/* ä½¿ç”¨ä¸€ç§æ··åˆæè´¨çš„ InstancedMesh */}
            <instancedMesh ref={meshRef} args={[geometries[0], null, count]}>
                <meshStandardMaterial metalness={1} roughness={0.1} color="#00ffcc" />
            </instancedMesh>

            {grabbedImg && (
                <Float speed={4} rotationIntensity={1} floatIntensity={2}>
                    <mesh position={[0, 2, 12]}>
                        <planeGeometry args={[7, 9]} />
                        <meshBasicMaterial map={grabbedImg} transparent opacity={0.9} />
                        <pointLight intensity={100} color="#00ffcc" distance={20} />
                    </mesh>
                </Float>
            )}
        </group>
    );
};

// --- ä¸»åœºæ™¯ ---
const Scene = () => {
    const [images, setImages] = useState([]);

    useEffect(() => {
        // éšè—åŠ è½½æç¤º
        const loader = document.getElementById('loading-ui');
        if (loader) loader.style.display = 'none';

        // åˆå§‹åŒ–æ‘„åƒå¤´ AI
        const video = document.getElementById('webcam');
        const canvasElement = document.getElementById('video-preview');
        const canvasCtx = canvasElement.getContext('2d');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        hands.onResults((results) => {
            // ç»˜åˆ¶é¢„è§ˆ
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                // æåˆåˆ¤æ–­
                const distPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                state.pinch = distPinch < 0.05;
                // æ¡æ‹³åˆ¤æ–­
                state.gesture = lm[12].y > lm[9].y ? 'fist' : 'open';
                // ç¼©æ”¾
                state.scale = 0.5 + (lm[0].y - lm[12].y) * 2;
            }
        });

        const camera = new Camera(video, {
            onFrame: async () => { await hands.send({ image: video }); },
            width: 480, height: 360
        });
        camera.start();

        // å›¾ç‰‡å¤„ç†
        const texLoader = new THREE.TextureLoader();
        document.getElementById('img-upload').onchange = (e) => {
            Array.from(e.target.files).forEach(file => {
                const url = URL.createObjectURL(file);
                texLoader.load(url, (t) => setImages(prev => [...prev, t]));
            });
        };
    }, []);

    return (
        <Canvas shadows>
            <PerspectiveCamera makeDefault position={[0, 5, 40]} />
            <color attach="background" args={['#020202']} />
            <fog attach="fog" args={['#000', 30, 90]} />
            
            <ambientLight intensity={0.4} />
            <spotLight position={[10, 20, 10]} angle={0.5} penumbra={1} intensity={200} castShadow />
            
            {/* æ ‘é¡¶ç¯æ³¡ */}
            <mesh position={[0, 13, 0]}>
                <sphereGeometry args={[0.6, 32, 32]} />
                <meshStandardMaterial emissive="#ffd700" emissiveIntensity={10} color="white" />
                <pointLight intensity={150} color="#ffd700" distance={30} />
            </mesh>

            <XmasParticles images={images} />

            <Environment preset="city" />

            {/* åœ°é¢åå°„ */}
            <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -12, 0]}>
                <planeGeometry args={[100, 100]} />
                <MeshReflectorMaterial
                    blur={[300, 100]} resolution={1024} mixBlur={1} mixStrength={60}
                    roughness={1} depthScale={1.2} minDepthThreshold={0.4} maxDepthThreshold={1.4}
                    color="#050505" metalness={0.5}
                />
            </mesh>

            <OrbitControls enablePan={false} maxPolarAngle={Math.PI / 1.8} />
        </Canvas>
    );
};

createRoot(document.getElementById('root')).render(<Scene />);
</script>
</body>
</html>
