<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; position: relative; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; z-index: 100; font-size: 14px; letter-spacing: 2px;
        }
        .ui-controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 101;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 15px;
            border: 1px solid #00ffcc; backdrop-filter: blur(10px); color: white;
        }
        button, label {
            padding: 8px 15px; background: #00ffcc; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold; font-size: 12px; margin: 5px 5px 0 0; display: inline-block;
        }
        #video-preview {
            position: absolute; top: 20px; right: 20px; width: 140px; height: 105px;
            border-radius: 12px; border: 2px solid #00ffcc; transform: scaleX(-1);
            background: #111; z-index: 101;
        }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨åŠ è½½ AI å¼•æ“...</div>
<div id="root"></div>
<video id="webcam" style="display:none" autoplay playsinline></video>
<canvas id="video-preview"></canvas>

<div class="ui-controls">
    <div style="font-size: 14px; margin-bottom: 8px; font-weight: bold;">ğŸ„ åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ</div>
    <label for="file-upload">ğŸ“‚ æ’å…¥ç…§ç‰‡/æ–‡æ¡£</label>
    <input type="file" id="file-upload" multiple accept="image/*" style="display:none">
    <button onclick="document.documentElement.requestFullscreen()">å…¨å±æ˜¾ç¤º</button>
    <div style="font-size: 11px; color: #00ffcc; margin-top: 5px;">
        ğŸ–ï¸ å¼ å¼€: æ‰©æ•£æ—‹è½¬ | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
    </div>
</div>

<!-- å¼•å…¥ MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "htm": "https://esm.sh/htm@3.1.1",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7?external=three,react,react-dom"
  }
}
</script>

<script type="module">
import React, { useState, useMemo, useRef, useEffect } from 'react';
import { createRoot } from 'react-dom';
import * as THREE from 'three';
import htm from 'htm';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Environment, Float, MeshReflectorMaterial, PerspectiveCamera } from '@react-three/drei';

const html = htm.bind(React.createElement);

// å…¨å±€æ‰‹åŠ¿çŠ¶æ€å•ä¾‹
const handState = { gesture: 'open', pinch: false, scale: 1 };

// --- æ ¸å¿ƒç²’å­ç»„ä»¶ ---
const XmasEngine = ({ photoTextures }) => {
    const count = 1800;
    const meshRef = useRef();
    const dummy = new THREE.Object3D();
    const [grabbedPhoto, setGrabbedPhoto] = useState(null);

    // å®šä¹‰ä¸åŒå½¢çŠ¶çš„å‡ ä½•ä½“
    const geometries = useMemo(() => [
        new THREE.SphereGeometry(0.2, 8, 8),      // åœ†çƒ
        new THREE.BoxGeometry(0.3, 0.3, 0.3),    // ç¤¼ç‰©ç›’
        new THREE.TorusGeometry(0.15, 0.05, 8, 16), // é“ƒé“›/åœ†ç¯
        new THREE.ConeGeometry(0.2, 0.4, 4),     // åœ£è¯æ ‘/ä¸‰è§’å½¢
        new THREE.CylinderGeometry(0.1, 0.1, 0.3, 6) // é¢†å¸¦/åœ†æŸ±
    ], []);

    const particles = useMemo(() => {
        const pArr = [];
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 137.5 * (Math.PI / 180);
            const r = (1 - t) * 10;
            const wave = Math.sin(t * 30) * 0.5;
            
            // åœ£è¯æ ‘åæ ‡ (è´¹é©¬èºæ—‹)
            const treePos = new THREE.Vector3(Math.cos(angle) * (r + wave), t * 24 - 10, Math.sin(angle) * (r + wave));
            // éšæœºæ‰©æ•£åæ ‡
            const randPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
            
            pArr.push({
                treePos,
                randPos,
                currPos: randPos.clone(),
                geoIdx: Math.floor(Math.random() * geometries.length),
                scale: 0.3 + Math.random() * 0.5
            });
        }
        return pArr;
    }, []);

    useFrame((state) => {
        const time = state.clock.getElapsedTime();
        const isFist = handState.gesture === 'fist';

        particles.forEach((p, i) => {
            let target = isFist ? p.treePos : p.randPos;
            
            // æ•£å¼€æ—¶çš„æ—‹è½¬åŠ¨æ€
            if (!isFist) {
                const rot = time * 0.3;
                const ox = p.randPos.x;
                const oz = p.randPos.z;
                target = new THREE.Vector3(ox * Math.cos(rot) - oz * Math.sin(rot), p.randPos.y, ox * Math.sin(rot) + oz * Math.cos(rot));
            }

            p.currPos.lerp(target, 0.06); // ä¸æ»‘è¿‡æ¸¡
            dummy.position.copy(p.currPos);
            dummy.scale.setScalar(p.scale * handState.scale);
            dummy.rotation.set(time * 0.5, time * 0.3, 0);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;

        // æåˆæŠ“å–é€»è¾‘
        if (handState.pinch && photoTextures.length > 0 && !grabbedPhoto) {
            setGrabbedPhoto(photoTextures[Math.floor(Math.random() * photoTextures.length)]);
        } else if (!handState.pinch) {
            setGrabbedPhoto(null);
        }
    });

    return html`
        <group>
            <instancedMesh ref=${meshRef} args=${[geometries[0], null, count]}>
                <meshStandardMaterial metalness=${1} roughness=${0.1} color="#00ffcc" envMapIntensity=${2} />
            </instancedMesh>

            ${grabbedPhoto && html`
                <${Float} speed=${5} rotationIntensity=${2}>
                    <mesh position=${[0, 2, 10]}>
                        <planeGeometry args=${[8, 10]} />
                        <meshBasicMaterial map=${grabbedPhoto} transparent opacity=${0.9} />
                        <!-- ç…§ç‰‡å…‰æ™• -->
                        <pointLight intensity=${150} color="#00ffcc" distance=${25} />
                    </mesh>
                <//>
            `}
        </group>
    `;
};

// --- ä¸»åº”ç”¨ç»„ä»¶ ---
const App = () => {
    const [textures, setTextures] = useState([]);

    useEffect(() => {
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('video-preview');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        hands.onResults((res) => {
            loading.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(res.image, 0, 0, canvas.width, canvas.height);
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                handState.pinch = pinchDist < 0.05;
                handState.gesture = lm[12].y > lm[9].y ? 'fist' : 'open';
                handState.scale = 0.5 + (lm[0].y - lm[12].y) * 2;
            }
        });

        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({ image: video }); },
            width: 480, height: 360
        });
        cam.start();

        // æ’å…¥æ–‡ä»¶é€»è¾‘
        const texLoader = new THREE.TextureLoader();
        document.getElementById('file-upload').onchange = (e) => {
            Array.from(e.target.files).forEach(f => {
                const url = URL.createObjectURL(f);
                texLoader.load(url, (t) => setTextures(prev => [...prev, t]));
            });
        };
    }, []);

    return html`
        <${Canvas} shadows>
            <${PerspectiveCamera} makeDefault position=${[0, 5, 40]} fov=${45} />
            <color attach="background" args=${['#020202']} />
            <fog attach="fog" args=${['#000', 30, 95]} />
            <ambientLight intensity=${0.4} />
            
            <!-- æ ‘é¡¶ç¯æ³¡ -->
            <mesh position=${[0, 14, 0]}>
                <sphereGeometry args=${[0.6, 32, 32]} />
                <meshStandardMaterial emissive="#ffd700" emissiveIntensity=${12} color="white" />
                <pointLight intensity=${180} color="#ffd700" distance=${40} />
            </mesh>

            <${XmasEngine} photoTextures=${textures} />
            <${Environment} preset="city" />

            <!-- åå°„åœ°é¢ -->
            <mesh rotation=${[-Math.PI / 2, 0, 0]} position=${[0, -12, 0]}>
                <planeGeometry args=${[100, 100]} />
                <${MeshReflectorMaterial}
                    blur=${[300, 100]} resolution=${1024} mixBlur=${1} mixStrength=${50}
                    roughness=${1} color="#080808" metalness=${0.5}
                />
            </mesh>

            <${OrbitControls} enablePan=${false} makeDefault />
        <//>
    `;
};

const container = document.getElementById('root');
const root = createRoot(container);
root.render(html`<${App} />`);
</script>
</body>
</html>
