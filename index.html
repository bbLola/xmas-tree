<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ - ç¨³å®šç‰ˆ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; }
        .ui-overlay {
            position: absolute; bottom: 30px; left: 30px; z-index: 100;
            background: rgba(0, 0, 0, 0.6); padding: 20px; border-radius: 20px;
            backdrop-filter: blur(15px); border: 1px solid rgba(0,255,204,0.3); color: white;
        }
        .btn {
            padding: 10px 20px; background: #00ffcc; border: none; border-radius: 10px;
            cursor: pointer; font-weight: bold; color: #000; margin-top: 10px; transition: 0.3s;
        }
        .btn:hover { background: #fff; box-shadow: 0 0 20px #00ffcc; }
        #video-preview {
            position: absolute; top: 20px; right: 20px; width: 140px; height: 105px;
            border-radius: 15px; border: 2px solid #00ffcc; transform: scaleX(-1);
            background: #111; z-index: 100; box-shadow: 0 0 20px rgba(0,255,204,0.3);
        }
        #loading-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-size: 14px; letter-spacing: 2px;
        }
    </style>
</head>
<body>

<div id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI ç²’å­å¼•æ“...</div>
<div id="root"></div>
<video id="webcam" style="display:none" autoplay playsinline></video>
<canvas id="video-preview"></canvas>

<div class="ui-overlay">
    <div style="font-weight: bold; font-size: 18px; margin-bottom: 8px;">ğŸ„ 3D AI åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ</div>
    <div style="font-size: 12px; color: #00ffcc;">ğŸ–ï¸ å¼ å¼€: æ‰©æ•£æ—‹è½¬ | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡</div>
    <label for="img-input" class="btn" style="display: inline-block;">ğŸ“ æ’å…¥æ–‡æ¡£/ç…§ç‰‡</label>
    <input type="file" id="img-input" multiple accept="image/*" style="display:none">
    <button class="btn" style="margin-left: 10px;" onclick="document.documentElement.requestFullscreen()">å…¨å±æ§åˆ¶</button>
</div>

<!-- åŠ è½½ MediaPipe æ‰‹åŠ¿åº“ -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "htm": "https://esm.sh/htm@3.1.1",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7?external=three,react,react-dom"
  }
}
</script>

<script type="module">
    import React from 'react';
    import { createRoot } from 'react-dom';
    import * as THREE from 'three';
    import htm from 'htm';
    import { Canvas, useFrame } from '@react-three/fiber';
    import { OrbitControls, Environment, Float, MeshReflectorMaterial, PerspectiveCamera } from '@react-three/drei';

    const { useState, useMemo, useRef, useEffect } = React;
    const html = htm.bind(React.createElement);

    // å…¨å±€æ‰‹åŠ¿çŠ¶æ€ï¼ˆç”¨äºæ¯ä¸€å¸§çš„é«˜é€Ÿè¯»å–ï¼‰
    const handStatus = { gesture: 'open', pinch: false, scale: 1 };

    // --- æ ¸å¿ƒç²’å­é€»è¾‘ ---
    const XmasParticles = ({ images }) => {
        const count = 1500;
        const meshRef = useRef();
        const dummy = new THREE.Object3D();
        const [grabbedImg, setGrabbedImg] = useState(null);

        // é¢„å®šä¹‰å¤šç§å‡ ä½•ä½“
        const geos = useMemo(() => [
            new THREE.SphereGeometry(0.2, 8, 8),
            new THREE.BoxGeometry(0.25, 0.25, 0.25),
            new THREE.TorusGeometry(0.12, 0.05, 8, 12),
            new THREE.ConeGeometry(0.18, 0.4, 4),
            new THREE.CylinderGeometry(0.1, 0.1, 0.3, 6)
        ], []);

        const particles = useMemo(() => {
            const temp = [];
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const angle = i * 137.5 * (Math.PI / 180);
                const r = (1 - t) * 10;
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * (r + Math.sin(t * 25) * 0.6),
                    t * 22 - 10,
                    Math.sin(angle) * (r + Math.sin(t * 25) * 0.6)
                );
                const randPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
                temp.push({ treePos, randPos, curr: randPos.clone(), size: 0.4 + Math.random() * 0.5 });
            }
            return temp;
        }, []);

        useFrame((state) => {
            const time = state.clock.getElapsedTime();
            const isFist = handStatus.gesture === 'fist';

            particles.forEach((p, i) => {
                let target = isFist ? p.treePos : p.randPos;
                
                // æ•£å¼€æ—¶çš„ä¼˜é›…æ—‹è½¬é€»è¾‘
                if (!isFist) {
                    const rot = time * 0.25;
                    const x = p.randPos.x, z = p.randPos.z;
                    target = new THREE.Vector3(x * Math.cos(rot) - z * Math.sin(rot), p.randPos.y, x * Math.sin(rot) + z * Math.cos(rot));
                }

                p.curr.lerp(target, 0.07); // ä¸æ»‘è¿‡æ¸¡æ ¸å¿ƒ
                dummy.position.copy(p.curr);
                dummy.scale.setScalar(p.size * handStatus.scale);
                dummy.rotation.set(time * 0.5, time * 0.3, 0);
                dummy.updateMatrix();
                meshRef.current.setMatrixAt(i, dummy.matrix);
            });
            meshRef.current.instanceMatrix.needsUpdate = true;

            // æåˆæŠ“å–åˆ¤å®š
            if (handStatus.pinch && images.length > 0 && !grabbedImg) {
                setGrabbedImg(images[Math.floor(Math.random() * images.length)]);
            } else if (!handStatus.pinch) {
                setGrabbedImg(null);
            }
        });

        return html`
            <group>
                <instancedMesh ref=${meshRef} args=${[null, null, count]}>
                    <sphereGeometry args=${[0.2, 12, 12]} />
                    <meshStandardMaterial metalness=${1} roughness=${0.1} color="#00ffcc" />
                </instancedMesh>

                ${grabbedImg && html`
                    <${Float} speed=${5} rotationIntensity=${2}>
                        <mesh position=${[0, 2, 12]}>
                            <planeGeometry args=${[8, 10]} />
                            <meshBasicMaterial map=${grabbedImg} transparent opacity=${0.95} />
                            <!-- æŠ“å–æ—¶çš„ç…§ç‰‡å…‰æ™•æ•ˆæœ -->
                            <pointLight intensity=${200} color="#00ffcc" distance=${30} />
                        </mesh>
                    <//>
                `}
            </group>
        `;
    };

    // --- ä¸»åœºæ™¯ç»„ä»¶ ---
    const App = () => {
        const [images, setImages] = useState([]);

        useEffect(() => {
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('video-preview');
            const ctx = canvas.getContext('2d');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
            hands.onResults((res) => {
                document.getElementById('loading-text').style.display = 'none';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(res.image, 0, 0, canvas.width, canvas.height);
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const lm = res.multiHandLandmarks[0];
                    handStatus.pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.05;
                    handStatus.gesture = lm[12].y > lm[9].y ? 'fist' : 'open';
                    handStatus.scale = 0.5 + (lm[0].y - lm[12].y) * 2;
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); },
                width: 480, height: 360
            });
            cam.start();

            const loader = new THREE.TextureLoader();
            document.getElementById('img-input').onchange = (e) => {
                Array.from(e.target.files).forEach(f => {
                    const url = URL.createObjectURL(f);
                    loader.load(url, (t) => setImages(p => [...p, t]));
                });
            };
        }, []);

        return html`
            <${Canvas}>
                <${PerspectiveCamera} makeDefault position=${[0, 5, 42]} />
                <color attach="background" args=${['#020202']} />
                <fog attach="fog" args=${['#000', 30, 95]} />
                
                <ambientLight intensity=${0.4} />
                <spotLight position=${[15, 25, 10]} angle=${0.5} intensity=${150} />
                
                <!-- æ ‘é¡¶æ˜äº®ç¯æ³¡ -->
                <mesh position=${[0, 13, 0]}>
                    <sphereGeometry args=${[0.6, 32, 32]} />
                    <meshStandardMaterial emissive="#ffd700" emissiveIntensity=${12} color="#fff" />
                    <pointLight intensity=${200} color="#ffd700" distance=${40} />
                </mesh>

                <${XmasParticles} images=${images} />
                <${Environment} preset="city" />

                <!-- é•œé¢åå°„åœ°é¢ -->
                <mesh rotation=${[-Math.PI / 2, 0, 0]} position=${[0, -12, 0]}>
                    <planeGeometry args=${[100, 100]} />
                    <${MeshReflectorMaterial} 
                        blur=${[300, 100]} resolution=${1024} mixBlur=${1} mixStrength=${60}
                        roughness=${1} color="#080808" metalness=${0.5}
                    />
                </mesh>

                <${OrbitControls} enablePan=${false} />
            <//>
        `;
    };

    createRoot(document.getElementById('root')).render(html`<${App} />`);
</script>
</body>
</html>
