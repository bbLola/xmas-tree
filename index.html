<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; }
        #loading-ui {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; z-index: 100; text-align: center; pointer-events: none;
        }
        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 101;
            background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 15px;
            border: 1px solid #00ffcc; color: white; backdrop-filter: blur(10px);
        }
        button, label {
            padding: 8px 15px; background: #00ffcc; border: none; border-radius: 5px;
            cursor: pointer; font-weight: bold; margin-top: 10px; display: inline-block;
        }
        #video-preview {
            position: absolute; top: 20px; right: 20px; width: 120px; height: 90px;
            border-radius: 10px; border: 2px solid #00ffcc; transform: scaleX(-1); z-index: 101;
        }
    </style>
</head>
<body>

<div id="loading-ui">æ­£åœ¨åŠ è½½ AI å¼•æ“ä¸ 3D èµ„æº...</div>
<div id="root"></div>
<video id="webcam" style="display:none" autoplay playsinline></video>
<canvas id="video-preview"></canvas>

<div class="controls">
    <div style="font-weight: bold;">ğŸ„ åœ£è¯ç²’å­ç³»ç»Ÿ</div>
    <label for="img-upload">ğŸ“‚ æ’å…¥ç…§ç‰‡/æ–‡æ¡£</label>
    <input type="file" id="img-upload" multiple accept="image/*" style="display:none">
    <button onclick="document.documentElement.requestFullscreen()">å…¨å±æ§åˆ¶</button>
    <div style="font-size: 11px; color: #00ffcc; margin-top: 8px;">
        ğŸ–ï¸ å¼ å¼€: æ‰©æ•£æ—‹è½¬ | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
    </div>
</div>

<!-- åŠ è½½ MediaPipe æ‰‹åŠ¿è¯†åˆ« -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<!-- åŠ è½½ Babel ä»¥è§£æ JSX -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7?external=three,react,react-dom"
  }
}
</script>

<script type="text/babel" data-type="module">
import React, { useState, useMemo, useRef, useEffect } from 'react';
import { createRoot } from 'react-dom';
import * as THREE from 'three';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Environment, Float, MeshReflectorMaterial, ContactShadows } from '@react-three/drei';

// å…¨å±€æ‰‹åŠ¿çŠ¶æ€ï¼ˆè·¨ç»„ä»¶å…±äº«ï¼Œç¡®ä¿å“åº”æ— å»¶è¿Ÿï¼‰
const handData = { gesture: 'open', pinch: false, scale: 1, pos: new THREE.Vector3() };

// --- åœ£è¯å½¢çŠ¶ç²’å­ç»„ä»¶ ---
const XmasParticles = ({ textures }) => {
    const count = 1500;
    const meshRef = useRef();
    const dummy = new THREE.Object3D();
    const [activeTexture, setActiveTexture] = useState(null);

    // å½¢çŠ¶å®šä¹‰ï¼šçƒã€ç¤¼ç‰©ç›’ã€é“ƒé“›ã€æ ‘ã€åœ†æŸ±
    const geos = useMemo(() => [
        new THREE.SphereGeometry(0.2, 8, 8),      // åœ†çƒ
        new THREE.BoxGeometry(0.3, 0.3, 0.3),    // ç¤¼ç‰©/æ­£æ–¹ä½“
        new THREE.TorusGeometry(0.15, 0.05, 8, 12), // é“ƒé“›/åœ†ç¯
        new THREE.ConeGeometry(0.2, 0.4, 4),     // åœ£è¯æ ‘/ä¸‰è§’å½¢
        new THREE.CylinderGeometry(0.1, 0.1, 0.3) // è¢œå­/é¢†å¸¦åŸå‹
    ], []);

    const particles = useMemo(() => {
        const data = [];
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 137.5 * (Math.PI / 180);
            const r = (1 - t) * 10;
            const treePos = new THREE.Vector3(
                Math.cos(angle) * (r + Math.sin(t * 30) * 0.5),
                t * 22 - 10,
                Math.sin(angle) * (r + Math.sin(t * 30) * 0.5)
            );
            const randPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
            data.push({ 
                treePos, 
                randPos, 
                currPos: randPos.clone(), 
                geoIdx: Math.floor(Math.random() * geos.length),
                rotSpeed: Math.random() * 0.02,
                size: 0.4 + Math.random() * 0.5
            });
        }
        return data;
    }, []);

    useFrame((state) => {
        const time = state.clock.getElapsedTime();
        const isFist = handData.gesture === 'fist';

        particles.forEach((p, i) => {
            let target = isFist ? p.treePos : p.randPos;
            
            // æ•£å¼€æ—‹è½¬åŠ¨æ•ˆ
            if (!isFist) {
                const s = Math.sin(time * 0.3), c = Math.cos(time * 0.3);
                const x = target.x, z = target.z;
                target.x = x * c - z * s;
                target.z = x * s + z * c;
            }

            p.currPos.lerp(target, 0.07);
            dummy.position.copy(p.currPos);
            dummy.scale.setScalar(p.size * handData.scale);
            dummy.rotation.set(time * p.rotSpeed * 10, time * p.rotSpeed * 5, 0);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;

        // æåˆæŠ“å–ç…§ç‰‡é€»è¾‘
        if (handData.pinch && textures.length > 0 && !activeTexture) {
            setActiveTexture(textures[Math.floor(Math.random() * textures.length)]);
        } else if (!handData.pinch) {
            setActiveTexture(null);
        }
    });

    return (
        <group>
            <instancedMesh ref={meshRef} args={[geometries[0], null, count]}>
                <sphereGeometry args={[0.2, 12, 12]} />
                <meshStandardMaterial metalness={1} roughness={0.1} color="#00ffcc" envMapIntensity={2} />
            </instancedMesh>

            {activeTexture && (
                <Float speed={5} rotationIntensity={2}>
                    <mesh position={[0, 0, 12]}>
                        <planeGeometry args={[8, 10]} />
                        <meshBasicMaterial map={activeTexture} transparent opacity={0.9} />
                        <pointLight intensity={150} color="#00ffcc" distance={25} />
                    </mesh>
                </Float>
            )}
        </group>
    );
};

// --- é¡¶çº§åœºæ™¯ ---
const App = () => {
    const [textures, setTextures] = useState([]);

    useEffect(() => {
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('video-preview');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading-ui');

        // åˆå§‹åŒ– MediaPipe
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        
        hands.onResults((res) => {
            loading.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(res.image, 0, 0, canvas.width, canvas.height);
            
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                handData.pinch = pinchDist < 0.05;
                handData.gesture = lm[12].y > lm[9].y ? 'fist' : 'open';
                handData.scale = 0.5 + (lm[0].y - lm[12].y) * 2;
            }
        });

        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({ image: video }); },
            width: 480, height: 360
        });
        cam.start();

        // æ’å…¥ç…§ç‰‡é€»è¾‘
        const texLoader = new THREE.TextureLoader();
        document.getElementById('img-upload').onchange = (e) => {
            Array.from(e.target.files).forEach(f => {
                const url = URL.createObjectURL(f);
                texLoader.load(url, (t) => setTextures(prev => [...prev, t]));
            });
        };
    }, []);

    return (
        <Canvas shadows dpr={[1, 2]}>
            <color attach="background" args={['#020202']} />
            <fog attach="fog" args={['#000', 30, 95]} />
            <ambientLight intensity={0.4} />
            
            {/* æ ‘é¡¶æ˜äº®ç¯æ³¡ */}
            <mesh position={[0, 13, 0]}>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial emissive="#ffd700" emissiveIntensity={12} color="white" />
                <pointLight intensity={200} color="#ffd700" distance={40} />
            </mesh>

            <XmasParticles textures={textures} />
            
            <Environment preset="city" />
            
            {/* ä¸æ»‘åœ°é¢åå°„ */}
            <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -12, 0]}>
                <planeGeometry args={[100, 100]} />
                <MeshReflectorMaterial
                    blur={[300, 100]} resolution={1024} mixBlur={1} mixStrength={50}
                    roughness={1} depthScale={1.2} minDepthThreshold={0.4} maxDepthThreshold={1.4}
                    color="#080808" metalness={0.5}
                />
            </mesh>
            
            <OrbitControls enablePan={false} makeDefault />
        </Canvas>
    );
};

const root = createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
