<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ‰‹åŠ¿äº¤äº’åœ£è¯ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: -apple-system, sans-serif; }
        #root { width: 100vw; height: 100vh; }
        
        /* UI æ ·å¼ */
        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px;
            background: rgba(255, 255, 255, 0.1); padding: 15px;
            border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
        }
        .controls h3 { color: white; margin: 0 0 10px 0; font-size: 14px; }
        .btn-group { display: flex; gap: 10px; }
        button, label {
            padding: 8px 15px; background: white; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold; font-size: 12px; transition: 0.3s;
        }
        button:hover { background: #00ffcc; }
        #video-container {
            position: absolute; top: 20px; right: 20px; width: 160px; height: 120px;
            border-radius: 10px; overflow: hidden; border: 2px solid #00ffcc; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        .hint {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.5); pointer-events: none; text-align: center;
        }
        #fullscreen-btn { position: absolute; top: 20px; left: 20px; z-index: 101; }
    </style>
</head>
<body>

<div id="root"></div>

<!-- æ‰‹åŠ¿è¯†åˆ«æ‘„åƒå¤´åé¦ˆ -->
<div id="video-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<div class="hint" id="loading-hint">æ­£åœ¨åˆå§‹åŒ– AI æ‘„åƒå¤´...</div>

<!-- UI ç•Œé¢ -->
<div class="controls">
    <h3>åœ£è¯å›¾ç‰‡ä»“åº“</h3>
    <div class="btn-group">
        <label for="img-upload">æ·»åŠ ç…§ç‰‡/æ–‡æ¡£</label>
        <input type="file" id="img-upload" multiple accept="image/*" style="display:none">
        <button id="fullscreen-btn-el">å…¨å±æ§åˆ¶</button>
    </div>
    <div style="color: #00ffcc; font-size: 11px; margin-top: 5px;">
        ğŸ‘Œ æåˆ: æŠ“å– | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ–ï¸ å¼ å¼€: æ•£å¼€æ—‹è½¬
    </div>
</div>

<!-- ä¾èµ–åº“ Importmap -->
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7?external=three,react,react-dom"
  }
}
</script>

<!-- å¼•å…¥ MediaPipe æ‰‹åŠ¿åº“ -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

<script type="module">
import React, { useState, useMemo, useRef, useEffect, Suspense } from 'react';
import { createRoot } from 'react-dom';
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, Environment, Float, Text, ContactShadows, MeshReflectorMaterial } from '@react-three/drei';

// --- å…¨å±€æ‰‹åŠ¿çŠ¶æ€ ---
let handState = { gesture: 'open', x: 0, y: 0, pinch: false, scale: 1 };

// --- åˆå§‹åŒ– MediaPipe ---
function initAI() {
    const videoElement = document.getElementById('webcam');
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            document.getElementById('loading-hint').style.display = 'none';
            const lm = results.multiHandLandmarks[0];
            
            // åˆ¤å®šé€»è¾‘
            const thumbTip = lm[4];
            const indexTip = lm[8];
            const middleTip = lm[12];
            
            // 1. æåˆåˆ¤æ–­ (æ‹‡æŒ‡é£ŸæŒ‡è·ç¦»)
            const distPinch = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            handState.pinch = distPinch < 0.05;

            // 2. æ¡æ‹³åˆ¤æ–­ (ä¸­æŒ‡æŒ‡å°–æ˜¯å¦ä½äºæŒ‡æ ¹)
            const isFist = middleTip.y > lm[9].y;
            handState.gesture = isFist ? 'fist' : 'open';

            // 3. åæ ‡æ˜ å°„ (åè½¬X)
            handState.x = (0.5 - indexTip.x) * 40;
            handState.y = (0.5 - indexTip.y) * 40;
            
            // 4. ç¼©æ”¾æ§åˆ¶ (æ ¹æ®æ‰‹éƒ¨æ•´ä½“é«˜åº¦)
            handState.scale = 1.0 + (lm[0].y - lm[12].y);
        }
    });

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 640, height: 480
    });
    camera.start();
}

// --- ç²’å­ä¸å›¾ç‰‡æ··åˆç»„ä»¶ ---
const ParticleSystem = ({ images }) => {
    const count = 1500;
    const { viewport } = useThree();
    const dummy = new THREE.Object3D();
    const [selectedImg, setSelectedImg] = useState(null);

    // ç”Ÿæˆç²’å­åŸºç¡€æ•°æ®
    const particles = useMemo(() => {
        const temp = [];
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 137.5 * (Math.PI / 180);
            
            // æ ‘å½¢ç›®æ ‡åæ ‡
            const r = (1 - t) * 10;
            const wave = Math.sin(t * 30) * 0.5;
            const treePos = new THREE.Vector3(Math.cos(angle) * (r + wave), t * 25 - 10, Math.sin(angle) * (r + wave));
            
            // éšæœºæ•£å¼€åæ ‡
            const randPos = new THREE.Vector3((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
            
            // å½¢çŠ¶ä¸é¢œè‰²
            const type = Math.floor(Math.random() * 5); // 0:çƒ, 1:æ–¹å—, 2:é”¥...
            const color = new THREE.Color(['#ff0000', '#00ff00', '#ffd700', '#ffffff', '#00ffff'][type]);
            
            temp.push({ treePos, randPos, currPos: randPos.clone(), color, type, scale: 0.3 + Math.random() * 0.4 });
        }
        return temp;
    }, []);

    // æ¯ä¸€å¸§çš„é€»è¾‘æ›´æ–°
    const meshRef = useRef();
    useFrame((state) => {
        const time = state.clock.getElapsedTime();
        const isFist = handState.gesture === 'fist';
        const isPinch = handState.pinch;

        particles.forEach((p, i) => {
            let target = isFist ? p.treePos : p.randPos;
            
            // æ—‹è½¬é€»è¾‘ï¼šå¦‚æœæ˜¯æ•£å¼€çŠ¶æ€ï¼Œç¼“æ…¢æ—‹è½¬
            if (!isFist) {
                const rotSpeed = 0.5;
                const ox = p.randPos.x;
                const oz = p.randPos.z;
                target.x = ox * Math.cos(time * rotSpeed) - oz * Math.sin(time * rotSpeed);
                target.z = ox * Math.sin(time * rotSpeed) + oz * Math.cos(time * rotSpeed);
            }

            p.currPos.lerp(target, 0.05);
            dummy.position.copy(p.currPos);
            dummy.scale.setScalar(p.scale * handState.scale);
            dummy.rotation.set(time * 0.5, time * 0.3, 0);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;

        // æåˆæŠ“å–åˆ¤å®š (éå¸¸ç®€å•çš„æœ€è¿‘ç‚¹ç®—æ³•)
        if (isPinch && images.length > 0 && !selectedImg) {
            setSelectedImg(images[Math.floor(Math.random() * images.length)]);
        } else if (!isPinch) {
            setSelectedImg(null);
        }
    });

    return (
        <group>
            {/* ç²’å­ä¸»ä½“ï¼šä½¿ç”¨å®ä¾‹åŒ–ç½‘æ ¼æå‡æ€§èƒ½ */}
            <instancedMesh ref={meshRef} args={[null, null, count]}>
                <sphereGeometry args={[0.3, 8, 8]} />
                <meshStandardMaterial roughness={0} metalness={1} envMapIntensity={2} />
            </instancedMesh>

            {/* é€‰ä¸­çš„ç…§ç‰‡å¼¹å‡ºåŠ¨æ•ˆ */}
            {selectedImg && (
                <Float speed={5} rotationIntensity={2} floatIntensity={2}>
                    <mesh position={[0, 0, 10]}>
                        <planeGeometry args={[8, 10]} />
                        <meshBasicMaterial map={selectedImg.texture} transparent opacity={0.9} />
                        {/* ç…§ç‰‡å…‰æ™• */}
                        <pointLight color="#00ffcc" intensity={50} distance={20} />
                    </mesh>
                    <Text position={[0, -6, 10]} fontSize={0.5} color="white">
                        {selectedImg.name}
                    </Text>
                </Float>
            )}
        </group>
    );
};

// --- ä¸»åº”ç”¨åœºæ™¯ ---
const App = () => {
    const [images, setImages] = useState([]);
    
    // å›¾ç‰‡ä¸Šä¼ å¤„ç†
    useEffect(() => {
        const loader = new THREE.TextureLoader();
        const upload = document.getElementById('img-upload');
        upload.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const url = URL.createObjectURL(file);
                loader.load(url, (txt) => {
                    setImages(prev => [...prev, { texture: txt, name: file.name }]);
                });
            });
        });

        // å…¨å±é€»è¾‘
        document.getElementById('fullscreen-btn-el').onclick = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        };

        initAI();
    }, []);

    return (
        <Canvas shadows camera={{ position: [0, 5, 45], fov: 45 }}>
            <color attach="background" args={['#050505']} />
            
            {/* ç¯å¢ƒå…‰æ•ˆ */}
            <fog attach="fog" args={['#050505', 30, 100]} />
            <ambientLight intensity={0.5} />
            <spotLight position={[0, 40, 0]} angle={0.5} penumbra={1} intensity={100} castShadow />
            
            {/* æ ‘é¡¶ç¯æ³¡ç²’å­ */}
            <mesh position={[0, 15, 0]}>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial color="#fff" emissive="#ffd700" emissiveIntensity={10} />
                <pointLight intensity={100} color="#ffd700" />
            </mesh>

            <Suspense fallback={null}>
                <ParticleSystem images={images} />
                <Environment preset="city" />
            </Suspense>

            {/* åœ°é¢åå°„ */}
            <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -12, 0]}>
                <planeGeometry args={[100, 100]} />
                <MeshReflectorMaterial
                    blur={[300, 100]}
                    resolution={1024}
                    mixBlur={1}
                    mixStrength={60}
                    roughness={1}
                    depthScale={1.2}
                    minDepthThreshold={0.4}
                    maxDepthThreshold={1.4}
                    color="#151515"
                    metalness={0.5}
                />
            </mesh>
            
            <OrbitControls makeDefault enablePan={false} maxPolarAngle={Math.PI / 2} />
        </Canvas>
    );
};

const root = createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>