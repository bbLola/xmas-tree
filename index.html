<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ‰‹åŠ¿äº¤äº’åœ£è¯ç²’å­ç³»ç»Ÿ - ç¨³å®šç‰ˆ</title>
    <style>
        body { margin: 0; background-color: #050505; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; position: relative; z-index: 1; }
        
        /* çŠ¶æ€æç¤º */
        #status-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 10; pointer-events: none; text-align: center;
            font-size: 14px; letter-spacing: 1px; transition: opacity 0.5s;
        }

        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.1); padding: 15px;
            border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
        }
        button, label {
            padding: 8px 15px; background: white; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold; font-size: 12px; margin-right: 5px;
        }
        #video-container {
            position: absolute; top: 20px; right: 20px; width: 160px; height: 120px;
            border-radius: 10px; overflow: hidden; border: 2px solid #00ffcc; transform: scaleX(-1);
            background: #000; z-index: 100;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

<div id="status-overlay">æ­£åœ¨å‡†å¤‡ 3D å¼•æ“...</div>

<div id="root"></div>

<div id="video-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<div class="controls">
    <div style="color: white; margin-bottom: 10px; font-size: 14px; font-weight: bold;">åœ£è¯ç²’å­ç³»ç»Ÿæ§åˆ¶å°</div>
    <label for="img-upload">æ·»åŠ ç…§ç‰‡</label>
    <input type="file" id="img-upload" multiple accept="image/*" style="display:none">
    <button id="fs-btn">å…¨å±æ¨¡å¼</button>
    <div style="color: #00ffcc; font-size: 11px; margin-top: 8px;">
        ğŸ–ï¸ å¼ å¼€: æ—‹è½¬æ•£å¼€ | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
    </div>
</div>

<!-- å¼•å…¥è„šæœ¬ -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.11?external=three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.92.7?external=three,react,react-dom"
  }
}
</script>

<script type="module">
import React, { useState, useMemo, useRef, useEffect } from 'react';
import { createRoot } from 'react-dom';
import * as THREE from 'three';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Environment, Float, Text, ContactShadows, MeshReflectorMaterial } from '@react-three/drei';

// å…¨å±€æ‰‹åŠ¿çŠ¶æ€
let handState = { gesture: 'open', x: 0, y: 0, pinch: false, scale: 1 };

// --- åœ£è¯æ ‘ç²’å­ç»„ä»¶ ---
const TreeParticles = ({ images }) => {
    const count = 2000;
    const dummy = new THREE.Object3D();
    const [selectedImg, setSelectedImg] = useState(null);

    const particles = useMemo(() => {
        const temp = [];
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 137.5 * (Math.PI / 180);
            const r = (1 - t) * 10;
            const wave = Math.sin(t * 30) * 0.5;
            const treePos = new THREE.Vector3(Math.cos(angle) * (r + wave), t * 25 - 10, Math.sin(angle) * (r + wave));
            const randPos = new THREE.Vector3((Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60);
            temp.push({ treePos, randPos, currPos: randPos.clone(), scale: 0.2 + Math.random() * 0.3 });
        }
        return temp;
    }, []);

    const meshRef = useRef();

    useFrame((state) => {
        const time = state.clock.getElapsedTime();
        const isFist = handState.gesture === 'fist';
        
        particles.forEach((p, i) => {
            let target = isFist ? p.treePos : p.randPos;
            if (!isFist) {
                // æ•£å¼€æ—¶ç»• Y è½´æ…¢é€Ÿæ—‹è½¬
                const s = Math.sin(time * 0.2), c = Math.cos(time * 0.2);
                const x = p.randPos.x, z = p.randPos.z;
                target = new THREE.Vector3(x * c - z * s, p.randPos.y, x * s + z * c);
            }
            p.currPos.lerp(target, 0.05);
            dummy.position.copy(p.currPos);
            dummy.scale.setScalar(p.scale * handState.scale);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;

        // æåˆé€»è¾‘
        if (handState.pinch && images.length > 0 && !selectedImg) {
            setSelectedImg(images[Math.floor(Math.random() * images.length)]);
        } else if (!handState.pinch) {
            setSelectedImg(null);
        }
    });

    return (
        <group>
            <instancedMesh ref={meshRef} args={[null, null, count]}>
                <sphereGeometry args={[0.3, 8, 8]} />
                <meshStandardMaterial roughness={0} metalness={1} color="#00ffcc" />
            </instancedMesh>
            {selectedImg && (
                <Float speed={5}>
                    <mesh position={[0, 0, 10]}>
                        <planeGeometry args={[8, 10]} />
                        <meshBasicMaterial map={selectedImg.texture} transparent />
                        <pointLight color="white" intensity={100} distance={20} />
                    </mesh>
                </Float>
            )}
        </group>
    );
};

// --- ä¸»åº”ç”¨ ---
const App = () => {
    const [images, setImages] = useState([]);

    useEffect(() => {
        const overlay = document.getElementById('status-overlay');
        
        // 1. åˆå§‹åŒ– AI (å¢åŠ å»¶è¿Ÿç¡®ä¿ä¾èµ–å·²åŠ è½½)
        setTimeout(() => {
            if (typeof Hands === 'undefined') {
                overlay.innerText = "åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
                return;
            }
            
            overlay.innerText = "è¯·æ±‚æ‘„åƒå¤´æƒé™...";
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
            
            hands.onResults((results) => {
                overlay.style.opacity = '0';
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const distPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    handState.pinch = distPinch < 0.06;
                    handState.gesture = lm[12].y > lm[9].y ? 'fist' : 'open';
                    handState.scale = 1.0 + (lm[0].y - lm[12].y);
                }
            });

            const camera = new Camera(document.getElementById('webcam'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('webcam') }); },
                width: 640, height: 480
            });
            camera.start().catch(() => {
                overlay.innerText = "æ— æ³•æ‰“å¼€æ‘„åƒå¤´ï¼Œå·²å¼€å¯é¼ æ ‡æ¨¡å¼";
                setTimeout(() => overlay.style.opacity = '0', 3000);
            });
        }, 1500);

        // 2. å›¾ç‰‡ä¸Šä¼ 
        const loader = new THREE.TextureLoader();
        document.getElementById('img-upload').onchange = (e) => {
            Array.from(e.target.files).forEach(f => {
                const url = URL.createObjectURL(f);
                loader.load(url, (t) => setImages(prev => [...prev, { texture: t }]));
            });
        };

        // 3. å…¨å±
        document.getElementById('fs-btn').onclick = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        };
    }, []);

    return (
        <Canvas shadows camera={{ position: [0, 5, 45], fov: 45 }}>
            <color attach="background" args={['#050505']} />
            <ambientLight intensity={0.5} />
            <pointLight position={[0, 15, 0]} color="#ffd700" intensity={150} />
            
            <TreeParticles images={images} />
            
            <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -11, 0]}>
                <planeGeometry args={[100, 100]} />
                <MeshReflectorMaterial color="#111" blur={[300, 100]} mixBlur={1} mixStrength={40} roughness={1} />
            </mesh>
            
            <Environment preset="city" />
            <OrbitControls enablePan={false} />
        </Canvas>
    );
};

const root = createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
